\section{Die While-Schleife \\ \footnotesize Wie die For-Schleife nur abstrakter und open-end}

\begin{frame}
\begin{block}{Problemstellung}
	\vspace{2pt}
	Lies immer wieder eine Zahl von der Konsole ein. Höre auf, wenn diese Zahl 7 ist. 
	
	Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}
	
\begin{block}{Lösung}
		\vspace{2pt}
		
	\begin{minted}{python}
		x = 0
		
		while x != 7: 
		  x = input("Gib eine Zahl an: ")
		  x = int(x)
		  
		print("Fertig!")
	\end{minted}
	
\end{block}
\end{fragile}

\begin{frame}

\renewcommand{\baselinestretch}{1.5}
\metroset{block=fill}
\begin{block}{Struktur der \texttt{while}-Schleife}
	\vspace{2pt}
	\pause \py{while} \pause \textit{Bedingung}\pause\texttt{:} \pause \\
	\spacechar\spacechar Codezeile 1 \pause \\ 
	\spacechar\spacechar Codezeile 2 \pause \\
	\spacechar\spacechar \phantom{Code} \vdots \pause  \\
	\textit{Code, der nicht mehr Teil der Schleife ist}
\end{block}
\vspace{12pt}
\pause 
\metroset{block=transparent}
\renewcommand{\baselinestretch}{1}
\begin{block}{Wie funktioniert's?}
	\vspace{2pt}
	Die Schleife wird solange ausgeführt, solange die \emph{Bedingung} \py{True} ergibt. Nach jedem Durchgang wird der Ausdruck der \emph{Bedingung} neu ausgewertet. 
	Ist die Bedingung \py{False} wird der Code unterhalb des Schleifenblocks ausgeführt. 
\end{block}

\end{frame}

\begin{frame}
\begin{alertblock}{Achtung Endlosschleife}
	\vspace{2pt}
	Man sollte immer darauf achten, dass die Bedingung in der \pybw{while}-Schleife auch wirklich irgendwannmal \py{False} wird. Ansonsten bleibt das Programm in einer \emph{Endlosschleife} gefangen. 
\end{alertblock}
\end{frame}

\begin{fragile}[Übung]

\begin{block}{Ersetze eine \pybw{for}-Schleife durch eine \pybw{while}-Schleife}
\vspace{2pt}
Schreibe ein Skript, das alle Zahlen von 1 bis 100 auf der Konsole ausgibt. Verwende eine While-Schleife.
\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
k = 1
while k <= 100:
  print(k)
  k += 1
\end{minted}
\end{solutionblock}
\end{block}
\end{fragile}


\begin{fragile}[Übung]
\begin{block}{Quizfrage}
\vspace{2pt}
Schreibe ein Programm, dass solange nach einer Hauptstadt Deiner Wahl fragt, bis die richtige Antwort eingegeben wird. 
\end{block}

\pause 
\vspace{12pt}

\begin{exampleblock}{Beispiel}
\vspace{2pt}


\console{Was ist die Hauptstadt von Frankreich?}

Darauf hin soll entsprechend der Antwort folgendes Feedback auf der Konsole erscheinen: 

\console{Das war richtig!} 

bzw. 

\console{Das war falsch! Versuch's gleich nochmal}
\end{exampleblock}
	
\end{fragile}


\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Quizfrage}
\begin{minted}{python}
answer = input("Was ist die Hauptstadt von Frankreich?")
while answer != "Paris": 
  print("Das war leider falsch, versuch es gleich nochmal")
  answer = input("")
print("Das war richtig!")
\end{minted}
\end{solutionblock}
\end{frame}


\begin{frame}{Übung}

\begin{block}{Ratespiel}
\vspace{2pt}
Definiere eine positive ganze Zahl \py{number_to_guess}. Der User kann nun wiederholt eine Zahl eingeben. Das Spiel endet, wenn die eingegebene Zahl mit \py{number_to_guess} übereinstimmt. 
Andernfalls wird auf der Konsole beispielsweise ausgegeben: 

\console{Sorry, Deine eingegebene Zahl war zu klein, versuche es nochmal: }

\pause
\textbf{Zusatz 1:} \\
Am Ende soll die Anzahl der Versuche angegeben werden.


\pause
\textbf{Zusatz 2:} \\
Google, wie Python die Zahl \py{number_to_guess} zufällig erzeugen kann (das verbessert das Gameplay).  

\end{block}
\end{frame}



\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel ohne Zusätze}
\begin{minted}{python}
number_to_guess = 512
guess = input("Rate meine Zahl: ")
guess = int(guess)

while guess != number_to_guess:
  if guess < number_to_guess:
    print("Deine Zahl war zu klein")
  else:
    print("Deine Zahl war zu groß")
  guess = input("Versuch's nochmal: ")
  guess = int(guess)

print("Du hast gewonnen")
\end{minted}
\end{solutionblock}
\end{frame}


\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel mit Zusatz 1}
\begin{minted}{python}
number_to_guess = 512
guess = input("Rate meine Zahl: ")
guess = int(guess)
counter = 1

while guess != number_to_guess:
  if guess < number_to_guess:
    print("Deine Zahl war zu klein")
  else:
    print("Deine Zahl war zu groß")
  guess = input("Versuch's nochmal: ")
  guess = int(guess)
  counter = counter + 1
  
print(f"Du hast nach {counter} Versuchen gewonnen")	
\end{minted}
\end{solutionblock}
\end{frame}






\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel mit Zusatz 2}
\begin{minted}{python}
import random 

number_to_guess = random.randint(1, 1000)
guess = input("Rate meine Zahl: ")
guess = int(guess)
# ... usw. 
\end{minted}
\end{solutionblock}
\end{frame}

\section{Den Schleifenfluss kontrollieren  \\ \footnotesize \texttt{break}, \texttt{continue} und \texttt{else}}


\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Das \texttt{break}-Statement}
Taucht innerhalb einer Schleife das Schlüsselwort \py{break} auf, so wird die weitere Abarbeitung der Schleife abgebrochen. Die Ausführung wird mit dem Code \emph{nach} dem Schleifenblock ausgeführt. 		
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{overprint}
	\onslide<2|handout:0>
\begin{minted}{python}
for k in range(1,100):
  print(k)
  if k > 3:
    break
print("fertig")
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
for k in range(1,100):
  print(k)
  if k > 3:
    break
print("fertig")
# 1 2 3 4 
# fertig
\end{minted}
\end{overprint}

\end{exampleblock}

	
\end{fragile}



\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Das \texttt{continue}-Statement}
Taucht innerhalb einer Schleife das Schlüsselwort \py{continue} auf, so wird der aktuelle Schleifendurchgang abgebrochen. Die Ausführung wird mit der nächsten Schleifeniteration fortgesetzt. 
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
for k in range(1,11):
  if k % 2 == 0:
    continue
  print(k)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
for k in range(1,11):
  if k % 2 == 0:
    continue
  print(k)
# 1 3 5 7 9 
\end{minted}
\end{overprint}
\end{exampleblock}
	
	
\end{fragile}


\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Der \texttt{else}-Block einer Schleife}
Analog zum \py{if}-Statement, kann auch eine Schleife einen \py{else}-Block haben. Dieser wird ausgeführt, wenn die Schleife \emph{regulär} (also nicht durch die Verwendung von \py{break}) beendet wird.  
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\begin{minted}{python}
name = input("Dein Name: ")

for letter in name: 
  if letter == "a" or letter == "A":
    print("Dein Name enthält ein A")
    break
else: 
  print("Dein Name enthält kein A")
\end{minted}
\end{exampleblock}
	
	
\end{fragile}



\begin{fragile}[Übungen]

\begin{block}{Zählen bis zur nächsten 10er-Zahl}
	\vspace{2pt}
Lies eine Zahl \pybw{x} ein und gib auf der Konsole die Zahlen von \pybw{x} bis zur nächsten 10er-Zahl aus. 
\\
Ist die Eingabe \pybw{x = 17}, so soll die Ausgabe wie folgt aussehen: 

\console{17}\\
\console{18}\\
\console{19}\\
\console{20}
\end{block}
	
\vspace{12pt}
\pause 

\begin{block}{Zählen mit Lücken}
	\vspace{2pt}
	Schreibe ein Skript, dass die Zahlen von 1 bis 99 aufzählt, dabei allerdings die 10er-Zahlen weglässt. Verwende dabei ein \pybw{continue}-Statement.
\end{block}
\end{fragile}

\begin{frame}<beamer:0>[fragile]{Lösungen}

\begin{solutionblock}{Zählen bis zur nächsten 10er-Zahl}
\begin{minted}{python}
x = input("Gib eine Zahl an: ")
x = int(x)

for k in range(x, x + 11):
  print(k)
  if k % 10 == 0:
    break
\end{minted}
\end{solutionblock}

\vspace{12pt}

\begin{solutionblock}{Zählen mit Lücken}
\begin{minted}{python}
for k in range(1, 100):
  if k % 10 == 0:
    continue
  print(k)
\end{minted}
\end{solutionblock}

\end{frame}

\begin{fragile}[Übung]
\begin{block}{Quizfrage mit Ausstiegsmöglichkeit}
\vspace{2pt}
Schreibe ein Programm, dass solange nach einer Hauptstadt Deiner Wahl fragt, bis die richtige Antwort eingegeben wird. Wird allerdings der Buchstabe \pybw{q} eingegeben, so bricht das Programm ab. 

\vspace{12pt}

\begin{solutionblock}{Quizfrage mit Ausstiegsmöglichkeit}
\begin{minted}{python}
answer = input("Was ist die Hauptstadt von Frankreich?")
while answer != "Paris": 
  print("Das war leider falsch, versuch es gleich nochmal")
  answer = input("")
  if answer == "q": 
    break
else: 
  print("Das war richtig!")
\end{minted}
\end{solutionblock}
\end{block}
\end{fragile}




\begin{fragile}[Harte Übung]
\begin{block}{Primzahltest}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein und überprüfe, ob diese Zahl eine Primzahl ist. Die Ausgabe des Programms soll etwa wie folgt aussehen:  

\console{Die Zahl 28061983 ist eine Primzahl.}
\end{block}

\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
x = input("Gib eine Zahl ein: ")
x = int(x)

for k in range(2, x):
  if x % k == 0:
    print(f"{x} ist keine Primzahl.")
    break
else:
  print(f"{x} ist eine Primzahl.")
\end{minted}
\end{solutionblock}

\end{fragile}




